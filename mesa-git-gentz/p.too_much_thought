diff --git a/include/EGL/eglmesaext.h b/include/EGL/eglmesaext.h
index f4332b279f8..3864f0dd416 100644
--- a/include/EGL/eglmesaext.h
+++ b/include/EGL/eglmesaext.h
@@ -86,6 +86,11 @@ typedef EGLBoolean (EGLAPIENTRYP PFNEGLSWAPBUFFERSREGIONNOK) (EGLDisplay dpy, EG
 #define EGL_DRM_BUFFER_FORMAT_RGB565_MESA       0x3292
 #endif /* EGL_MESA_drm_image_formats */
 
+#ifndef EGL_MESA_config_select_group
+#define EGL_MESA_config_select_group 1
+#define EGL_CONFIG_SELECT_GROUP_MESA		0x31D9
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/GL/internal/dri_interface.h b/include/GL/internal/dri_interface.h
index af0ee9c5667..09f7a798351 100644
--- a/include/GL/internal/dri_interface.h
+++ b/include/GL/internal/dri_interface.h
@@ -31,7 +31,7 @@
  * between a DRI driver and driver loader.  Currently, the most common driver
  * loader is the XFree86 libGL.so.  However, other loaders do exist, and in
  * the future the server-side libglx.a will also be a loader.
- * 
+ *
  * \author Kevin E. Martin <kevin@precisioninsight.com>
  * \author Ian Romanick <idr@us.ibm.com>
  * \author Kristian HÃ¸gsberg <krh@redhat.com>
@@ -51,6 +51,7 @@ typedef struct drm_clip_rect drm_clip_rect_t;
 #include <GL/gl.h>
 
 #include <stdint.h>
+#include <stdbool.h>
 
 /**
  * \name DRI interface structures
@@ -162,14 +163,14 @@ struct __DRIframeTrackingExtensionRec {
 
     /**
      * Enable or disable frame usage tracking.
-     * 
+     *
      * \since Internal API version 20030317.
      */
     int (*frameTracking)(__DRIdrawable *drawable, GLboolean enable);
 
     /**
      * Retrieve frame usage information.
-     * 
+     *
      * \since Internal API version 20030317.
      */
     int (*queryFrameTracking)(__DRIdrawable *drawable,
@@ -236,7 +237,7 @@ struct __DRItexBufferExtensionRec {
 
     /**
      * Method to override base texture image with the contents of a
-     * __DRIdrawable. 
+     * __DRIdrawable.
      *
      * For GLX_EXT_texture_from_pixmap with AIGLX.  Deprecated in favor of
      * setTexBuffer2 in version 2 of this interface
@@ -543,7 +544,7 @@ struct __DRIsystemTimeExtensionRec {
 
     /**
      * Get the media stream counter (MSC) rate.
-     * 
+     *
      * Matching the definition in GLX_OML_sync_control, this function returns
      * the rate of the "media stream counter".  In practical terms, this is
      * the frame refresh rate of the display.
@@ -766,10 +767,11 @@ struct __DRIuseInvalidateExtensionRec {
 #define __DRI_ATTRIB_YINVERTED			47
 #define __DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE	48
 #define __DRI_ATTRIB_MUTABLE_RENDER_BUFFER	49 /* EGL_MUTABLE_RENDER_BUFFER_BIT_KHR */
-#define __DRI_ATTRIB_MAX			50
+#define __DRI_ATTRIB_CONFIG_SELECT_GROUP	50
+#define __DRI_ATTRIB_MAX			51
 
 /* __DRI_ATTRIB_RENDER_TYPE */
-#define __DRI_ATTRIB_RGBA_BIT			0x01	
+#define __DRI_ATTRIB_RGBA_BIT			0x01
 #define __DRI_ATTRIB_COLOR_INDEX_BIT		0x02
 #define __DRI_ATTRIB_LUMINANCE_BIT		0x04
 #define __DRI_ATTRIB_FLOAT_BIT			0x08
@@ -809,6 +811,9 @@ struct __DRIuseInvalidateExtensionRec {
 #define __DRI_CORE "DRI_Core"
 #define __DRI_CORE_VERSION 2
 
+typedef bool
+(*__DRIconfigIsEglCompatibleFunc)(const __DRIconfig *a, const __DRIconfig *b);
+
 struct __DRIcoreExtensionRec {
     __DRIextension base;
 
@@ -855,12 +860,14 @@ struct __DRIcoreExtensionRec {
 		       __DRIdrawable *pread);
 
     int (*unbindContext)(__DRIcontext *ctx);
+
+    __DRIconfigIsEglCompatibleFunc       configIsEglCompatible;
 };
 
 /**
  * Stored version of some component (i.e., server-side DRI module, kernel-side
  * DRM, etc.).
- * 
+ *
  * \todo
  * There are several data structures that explicitly store a major version,
  * minor version, and patch level.  These structures should be modified to
@@ -875,7 +882,7 @@ struct __DRIversionRec {
 /**
  * Framebuffer information record.  Used by libGL to communicate information
  * about the framebuffer to the driver's \c __driCreateNewScreen function.
- * 
+ *
  * In XFree86, most of this information is derrived from data returned by
  * calling \c XF86DRIGetDeviceInfo.
  *
@@ -916,7 +923,7 @@ struct __DRIlegacyExtensionRec {
 				    const __DRIversion *dri_version,
 				    const __DRIversion *drm_version,
 				    const __DRIframebuffer *frame_buffer,
-				    void *pSAREA, int fd, 
+				    void *pSAREA, int fd,
 				    const __DRIextension **extensions,
 				    const __DRIconfig ***driver_configs,
 				    void *loaderPrivate);
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index d584bccdebe..fabb5dc3ce8 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -167,38 +167,136 @@ static const EGLint dri2_to_egl_attribute_map[__DRI_ATTRIB_MAX] = {
    [__DRI_ATTRIB_MAX_SWAP_INTERVAL]     = EGL_MAX_SWAP_INTERVAL,
    [__DRI_ATTRIB_MIN_SWAP_INTERVAL]     = EGL_MIN_SWAP_INTERVAL,
    [__DRI_ATTRIB_YINVERTED]             = EGL_Y_INVERTED_NOK,
+   [__DRI_ATTRIB_CONFIG_SELECT_GROUP]   = EGL_CONFIG_SELECT_GROUP_MESA,
 };
 
-const __DRIconfig *
-dri2_get_dri_config(struct dri2_egl_config *conf, EGLint surface_type,
-                    EGLenum colorspace)
+static EGLBoolean
+dri2_match_config(const _EGLConfig *egl_config, const _EGLConfig *cmp_to)
 {
-   const bool double_buffer = surface_type == EGL_WINDOW_BIT;
-   const bool srgb = colorspace == EGL_GL_COLORSPACE_SRGB_KHR;
+   if (egl_config->NativeVisualID != cmp_to->NativeVisualID)
+      return EGL_FALSE;
+
+   if (_eglCompareConfigs(egl_config, cmp_to, NULL, EGL_FALSE) != 0)
+      return EGL_FALSE;
+
+   if (!_eglMatchConfig(egl_config, cmp_to))
+      return EGL_FALSE;
+
+   return EGL_TRUE;
+}
 
-   return conf->dri_config[double_buffer][srgb];
+static EGLBoolean
+dri2_bundle_is_conf(struct dri2_egl_config_bundle *bundle, const _EGLConfig *egl_config)
+{
+   if (bundle->egl_config == egl_config)
+      return EGL_TRUE;
+   return EGL_FALSE;
 }
 
 static EGLBoolean
-dri2_match_config(const _EGLConfig *conf, const _EGLConfig *criteria)
+dri2_compatible_bundle(struct dri2_egl_config_bundle *bundle, const void **data)
 {
-   if (_eglCompareConfigs(conf, criteria, NULL, EGL_FALSE) != 0)
+   const __DRIconfig * const *dri_config = data[0];
+   __DRIconfigIsEglCompatibleFunc configIsEglCompatible = data[1];
+
+   const __DRIconfig *cmp_to = NULL;
+   int i;
+
+   for (i = 0; i < 4 && !cmp_to; ++i) {
+      cmp_to = bundle->dri_config[0][i];
+   }
+
+   if (i == 4) {
+      unreachable("Bundle has no dri configs");
       return EGL_FALSE;
+   }
+
+   if (configIsEglCompatible(cmp_to, *dri_config))
+      return EGL_TRUE;
 
-   if (!_eglMatchConfig(conf, criteria))
+   return EGL_FALSE;
+}
+
+static EGLBoolean
+dri2_root_has_conf(struct dri2_egl_config *root, _EGLConfig *egl_config)
+{
+   EGLint num_configs = 0;
+
+   num_configs = _eglFilterArray(root->bundles, NULL, 0,
+                                 (_EGLArrayForEach) dri2_bundle_is_conf,
+                                 egl_config);
+
+   if (num_configs == 1)
+      return EGL_TRUE;
+   else if (num_configs == 0)
       return EGL_FALSE;
 
-   return EGL_TRUE;
+   unreachable("Multiple bundles cannot match.");
+   return EGL_FALSE;
+}
+
+static void
+dri2_free_root(struct dri2_egl_config *root) {
+   if (root) {
+      _eglDestroyArray(root->bundles, free);
+      free(root);
+   }
+}
+
+struct dri2_egl_config_bundle *
+dri2_get_config_bundle(_EGLDisplay *disp, _EGLConfig *egl_config)
+{
+   EGLint num = 0;
+   struct dri2_egl_config *root;
+   struct dri2_egl_config_bundle *bundle;
+
+   num = _eglFilterArray(disp->ConfigRoots, (void **) &root, 1,
+                        (_EGLArrayForEach) dri2_root_has_conf, egl_config);
+
+   if (num > 1) {
+      unreachable("Each conf has exactly one root");
+      return NULL;
+   } else if (!num) {
+      return NULL;
+   }
+
+   num = _eglFilterArray(root->bundles, (void **) &bundle, 1,
+                        (_EGLArrayForEach) dri2_bundle_is_conf, egl_config);
+
+   if (num > 1) {
+      unreachable("Multiple bundles cannot match.");
+      return NULL;
+   } else if (!num) {
+      return NULL;
+   }
+
+   if (bundle->egl_config != egl_config) {
+      unreachable("Conf in bundle is not the same");
+      return NULL;
+   }
+
+   return bundle;
+}
+
+const __DRIconfig *
+dri2_get_dri_config(struct dri2_egl_config_bundle *bundle, EGLint surface_type,
+                    EGLenum colorspace)
+{
+   const bool double_buffer = surface_type == EGL_WINDOW_BIT;
+   const bool srgb = colorspace == EGL_GL_COLORSPACE_SRGB_KHR;
+
+   return bundle ? bundle->dri_config[double_buffer][srgb] : NULL;
 }
 
-struct dri2_egl_config *
+struct dri2_egl_config_bundle *
 dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
                 EGLint surface_type, const EGLint *attr_list,
                 const unsigned int *rgba_masks)
 {
-   struct dri2_egl_config *conf;
+   struct dri2_egl_config *root;
+   struct dri2_egl_config_bundle *bundle = NULL;
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   _EGLConfig base;
+   _EGLConfig egl_config;
    unsigned int attrib, value, double_buffer;
    bool srgb = false;
    EGLint key, bind_to_texture_rgb, bind_to_texture_rgba;
@@ -207,7 +305,7 @@ dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
    EGLint num_configs = 0;
    EGLint config_id;
 
-   _eglInitConfig(&base, disp, id);
+   _eglInitConfig(&egl_config, disp, id);
 
    double_buffer = 0;
    bind_to_texture_rgb = 0;
@@ -225,7 +323,7 @@ dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
             value = EGL_LUMINANCE_BUFFER;
          else
             return NULL;
-         _eglSetConfigKey(&base, EGL_COLOR_BUFFER_TYPE, value);
+         _eglSetConfigKey(&egl_config, EGL_COLOR_BUFFER_TYPE, value);
          break;
 
       case __DRI_ATTRIB_CONFIG_CAVEAT:
@@ -235,7 +333,7 @@ dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
             value = EGL_SLOW_CONFIG;
          else
             value = EGL_NONE;
-         _eglSetConfigKey(&base, EGL_CONFIG_CAVEAT, value);
+         _eglSetConfigKey(&egl_config, EGL_CONFIG_CAVEAT, value);
          break;
 
       case __DRI_ATTRIB_BIND_TO_TEXTURE_RGB:
@@ -282,11 +380,11 @@ dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
          break;
 
       case __DRI_ATTRIB_MAX_PBUFFER_WIDTH:
-         _eglSetConfigKey(&base, EGL_MAX_PBUFFER_WIDTH,
+         _eglSetConfigKey(&egl_config, EGL_MAX_PBUFFER_WIDTH,
                           _EGL_MAX_PBUFFER_WIDTH);
          break;
       case __DRI_ATTRIB_MAX_PBUFFER_HEIGHT:
-         _eglSetConfigKey(&base, EGL_MAX_PBUFFER_HEIGHT,
+         _eglSetConfigKey(&egl_config, EGL_MAX_PBUFFER_HEIGHT,
                           _EGL_MAX_PBUFFER_HEIGHT);
          break;
       case __DRI_ATTRIB_MUTABLE_RENDER_BUFFER:
@@ -296,70 +394,111 @@ dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
       default:
          key = dri2_to_egl_attribute_map[attrib];
          if (key != 0)
-            _eglSetConfigKey(&base, key, value);
+            _eglSetConfigKey(&egl_config, key, value);
          break;
       }
    }
 
    if (attr_list)
       for (int i = 0; attr_list[i] != EGL_NONE; i += 2)
-         _eglSetConfigKey(&base, attr_list[i], attr_list[i+1]);
+         _eglSetConfigKey(&egl_config, attr_list[i], attr_list[i+1]);
 
    if (rgba_masks && memcmp(rgba_masks, dri_masks, sizeof(dri_masks)))
       return NULL;
 
-   base.NativeRenderable = EGL_TRUE;
+   egl_config.NativeRenderable = EGL_TRUE;
 
-   base.SurfaceType = surface_type;
+   egl_config.SurfaceType = surface_type;
    if (surface_type & (EGL_PBUFFER_BIT |
        (disp->Extensions.NOK_texture_from_pixmap ? EGL_PIXMAP_BIT : 0))) {
-      base.BindToTextureRGB = bind_to_texture_rgb;
-      if (base.AlphaSize > 0)
-         base.BindToTextureRGBA = bind_to_texture_rgba;
+      egl_config.BindToTextureRGB = bind_to_texture_rgb;
+      if (egl_config.AlphaSize > 0)
+         egl_config.BindToTextureRGBA = bind_to_texture_rgba;
    }
 
-   base.RenderableType = disp->ClientAPIs;
-   base.Conformant = disp->ClientAPIs;
+   egl_config.RenderableType = disp->ClientAPIs;
+   egl_config.Conformant = disp->ClientAPIs;
 
-   base.MinSwapInterval = dri2_dpy->min_swap_interval;
-   base.MaxSwapInterval = dri2_dpy->max_swap_interval;
+   egl_config.MinSwapInterval = dri2_dpy->min_swap_interval;
+   egl_config.MaxSwapInterval = dri2_dpy->max_swap_interval;
 
-   if (!_eglValidateConfig(&base, EGL_FALSE)) {
+   if (!_eglValidateConfig(&egl_config, EGL_FALSE)) {
       _eglLog(_EGL_DEBUG, "DRI2: failed to validate config %d", id);
       return NULL;
    }
 
-   config_id = base.ConfigID;
-   base.ConfigID    = EGL_DONT_CARE;
-   base.SurfaceType = EGL_DONT_CARE;
+   config_id = egl_config.ConfigID;
+   egl_config.ConfigID    = EGL_DONT_CARE;
+   egl_config.SurfaceType = EGL_DONT_CARE;
    num_configs = _eglFilterArray(disp->Configs, (void **) &matching_config, 1,
-                                 (_EGLArrayForEach) dri2_match_config, &base);
+                                 (_EGLArrayForEach) dri2_match_config, &egl_config);
 
-   if (num_configs == 1) {
-      conf = (struct dri2_egl_config *) matching_config;
+   if (num_configs == 0) {
+      root = calloc(1, sizeof *root);
+      if (root == NULL)
+         return NULL;
 
-      if (!conf->dri_config[double_buffer][srgb])
-         conf->dri_config[double_buffer][srgb] = dri_config;
-      else
-         /* a similar config type is already added (unlikely) => discard */
+      root->bundles = _eglCreateArray("Dri Config", 8);
+      if (!root->bundles)
          return NULL;
-   }
-   else if (num_configs == 0) {
-      conf = calloc(1, sizeof *conf);
-      if (conf == NULL)
+   } else {
+      EGLint num_roots = 0;
+      EGLint num_bundles = 0;
+      const void *data[2];
+
+      num_roots = _eglFilterArray(disp->ConfigRoots, (void **) &root, 1,
+                                  (_EGLArrayForEach) dri2_root_has_conf,
+                                  matching_config);
+
+      if (num_roots != 1) {
+         unreachable("Each conf has exactly one root");
          return NULL;
+      }
 
-      conf->dri_config[double_buffer][srgb] = dri_config;
+      data[0] = (const void*) &dri_config;
+      data[1] = (const void*) dri2_dpy->core->configIsEglCompatible;
 
-      memcpy(&conf->base, &base, sizeof base);
-      conf->base.SurfaceType = 0;
-      conf->base.ConfigID = config_id;
+      num_bundles = _eglFilterArray(root->bundles, (void **) &bundle, 1,
+                                    (_EGLArrayForEach) dri2_compatible_bundle,
+                                    data);
 
-      _eglLinkConfig(&conf->base);
+      if (num_bundles > 1) {
+         unreachable("Can only be one compatible bundle");
+         return NULL;
+      }
    }
-   else {
-      unreachable("duplicates should not be possible");
-      return NULL;
+
+   if (!bundle) {
+      bundle = calloc(1, sizeof *bundle);
+
+      _eglAppendArray(root->bundles, (void *)bundle);
+
+      bundle->egl_config = calloc(1, sizeof egl_config);
+      if (bundle->egl_config == NULL)
+         return NULL;
+
+      bundle->dri_config[double_buffer][srgb] = dri_config;
+
+      memcpy(bundle->egl_config, &egl_config, sizeof egl_config);
+      bundle->egl_config->SurfaceType = 0;
+      bundle->egl_config->ConfigID = config_id;
+
+      _eglLinkConfig(bundle->egl_config, root, (void(*)(void *))dri2_free_root);
+   } else {
+      if (!bundle->egl_config) {
+         unreachable("Egl config missing from bundle.");
+         return NULL;
+      }
+
+      if (bundle->dri_config[double_buffer][srgb]) {
+         if (bundle->dri_config[double_buffer][srgb] == dri_config)
+            return bundle;
+
+         unreachable("Found compatible config already at place.");
+         return NULL;
+      }
+
+      bundle->dri_config[double_buffer][srgb] = dri_config;
    }
 
    if (double_buffer) {
@@ -371,13 +510,13 @@ dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
     * XXX TODO: pbuffer + MSAA does not work and causes crashes.
     * See QT bugreport: https://bugreports.qt.io/browse/QTBUG-47509
     */
-   if (base.Samples) {
+   if (egl_config.Samples) {
       surface_type &= ~EGL_PBUFFER_BIT;
    }
 
-   conf->base.SurfaceType |= surface_type;
+   bundle->egl_config->SurfaceType |= surface_type;
 
-   return conf;
+   return bundle;
 }
 
 __DRIimage *
@@ -1172,15 +1311,15 @@ dri2_create_context(_EGLDriver *drv, _EGLDisplay *disp, _EGLConfig *conf,
 {
    struct dri2_egl_context *dri2_ctx;
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_config_bundle *bundle = dri2_get_config_bundle(disp, conf);
    struct dri2_egl_context *dri2_ctx_shared = dri2_egl_context(share_list);
    __DRIcontext *shared =
       dri2_ctx_shared ? dri2_ctx_shared->dri_context : NULL;
-   struct dri2_egl_config *dri2_config = dri2_egl_config(conf);
-   const __DRIconfig *dri_config;
    int api;
    unsigned error;
    unsigned num_attribs = NUM_ATTRIBS;
    uint32_t ctx_attribs[NUM_ATTRIBS];
+   const __DRIconfig *dri_config;
 
    (void) drv;
 
@@ -1251,18 +1390,18 @@ dri2_create_context(_EGLDriver *drv, _EGLDisplay *disp, _EGLConfig *conf,
       return NULL;
    }
 
-   if (conf != NULL) {
-      /* The config chosen here isn't necessarily
-       * used for surfaces later.
-       * A pixmap surface will use the single config.
-       * This opportunity depends on disabling the
-       * doubleBufferMode check in
-       * src/mesa/main/context.c:check_compatible()
-       */
-      if (dri2_config->dri_config[1][0])
-         dri_config = dri2_config->dri_config[1][0];
+   /* The config chosen here isn't necessarily
+    * used for surfaces later.
+    * A pixmap surface will use the single config.
+    * This opportunity depends on disabling the
+    * doubleBufferMode check in
+    * src/mesa/main/context.c:check_compatible()
+    */
+   if (bundle) {
+      if (bundle->dri_config[1][0])
+         dri_config = bundle->dri_config[1][0];
       else
-         dri_config = dri2_config->dri_config[0][0];
+         dri_config = bundle->dri_config[0][0];
    }
    else
       dri_config = NULL;
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index aa143deb867..38c468e0660 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -339,10 +339,14 @@ struct dri2_egl_surface
    EGLBoolean enable_out_fence;
 };
 
+struct dri2_egl_config_bundle {
+   const __DRIconfig *dri_config[2][2];
+   _EGLConfig *egl_config;
+};
+
 struct dri2_egl_config
 {
-   _EGLConfig         base;
-   const __DRIconfig *dri_config[2][2];
+   _EGLArray *bundles;
 };
 
 struct dri2_egl_image
@@ -402,7 +406,7 @@ dri2_surface_get_dri_drawable(_EGLSurface *surf);
 __DRIimage *
 dri2_lookup_egl_image(__DRIscreen *screen, void *image, void *data);
 
-struct dri2_egl_config *
+struct dri2_egl_config_bundle *
 dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
                 EGLint surface_type, const EGLint *attr_list,
                 const unsigned int *rgba_masks);
@@ -496,9 +500,12 @@ void
 dri2_flush_drawable_for_swapbuffers(_EGLDisplay *disp, _EGLSurface *draw);
 
 const __DRIconfig *
-dri2_get_dri_config(struct dri2_egl_config *conf, EGLint surface_type,
+dri2_get_dri_config(struct dri2_egl_config_bundle *bundle, EGLint surface_type,
                     EGLenum colorspace);
 
+struct dri2_egl_config_bundle *
+dri2_get_config_bundle(_EGLDisplay *disp, _EGLConfig *conf);
+
 static inline void
 dri2_set_WL_bind_wayland_display(_EGLDriver *drv, _EGLDisplay *disp)
 {
diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index e9ea9e6002b..849beaa11ad 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -343,10 +343,10 @@ droid_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
 {
    __DRIcreateNewDrawableFunc createNewDrawable;
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
+   struct dri2_egl_config_bundle *dri_bundle = dri2_get_config_bundle(disp, conf);
    struct dri2_egl_surface *dri2_surf;
    struct ANativeWindow *window = native_window;
-   const __DRIconfig *config;
+   const __DRIconfig *dri_config;
 
    dri2_surf = calloc(1, sizeof *dri2_surf);
    if (!dri2_surf) {
@@ -369,18 +369,18 @@ droid_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
          goto cleanup_surface;
       }
 
-      if (format != dri2_conf->base.NativeVisualID) {
+      if (format != dri_bundle->egl_config.NativeVisualID) {
          _eglLog(_EGL_WARNING, "Native format mismatch: 0x%x != 0x%x",
-               format, dri2_conf->base.NativeVisualID);
+               format, dri_bundle->egl_config.NativeVisualID);
       }
 
       window->query(window, NATIVE_WINDOW_WIDTH, &dri2_surf->base.Width);
       window->query(window, NATIVE_WINDOW_HEIGHT, &dri2_surf->base.Height);
    }
 
-   config = dri2_get_dri_config(dri2_conf, type,
-                                dri2_surf->base.GLColorspace);
-   if (!config) {
+   dri_config = dri2_get_dri_config(dri_bundle, type,
+                                    dri2_surf->base.GLColorspace);
+   if (!dri_config) {
       _eglError(EGL_BAD_MATCH, "Unsupported surfacetype/colorspace configuration");
       goto cleanup_surface;
    }
@@ -390,7 +390,7 @@ droid_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
    else
       createNewDrawable = dri2_dpy->dri2->createNewDrawable;
 
-   dri2_surf->dri_drawable = (*createNewDrawable)(dri2_dpy->dri_screen, config,
+   dri2_surf->dri_drawable = (*createNewDrawable)(dri2_dpy->dri_screen, dri_config,
                                                   dri2_surf);
    if (dri2_surf->dri_drawable == NULL) {
       _eglError(EGL_BAD_ALLOC, "createNewDrawable");
@@ -1184,12 +1184,12 @@ droid_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *disp)
            EGL_NONE
          };
 
-         struct dri2_egl_config *dri2_conf =
+         struct dri2_egl_config_bundle *dri_bundle =
             dri2_add_config(disp, dri2_dpy->driver_configs[j],
                             config_count + 1, surface_type, config_attrs,
                             visuals[i].rgba_masks);
-         if (dri2_conf) {
-            if (dri2_conf->base.ConfigID == config_count + 1)
+         if (dri_bundle) {
+            if (dri_bundle->egl_config->ConfigID == config_count + 1)
                config_count++;
             format_count[i]++;
          }
diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index c1ab1c9b0f6..ae744be53b3 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -134,11 +134,11 @@ dri2_drm_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
                                const EGLint *attrib_list)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
+   struct dri2_egl_config_bundle *dri_bundle = dri2_get_config_bundle(disp, conf);
    struct dri2_egl_surface *dri2_surf;
    struct gbm_surface *surface = native_surface;
    struct gbm_dri_surface *surf;
-   const __DRIconfig *config;
+   const __DRIconfig *dri_config;
 
    (void) drv;
 
@@ -152,16 +152,15 @@ dri2_drm_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
                           attrib_list, false))
       goto cleanup_surf;
 
-   config = dri2_get_dri_config(dri2_conf, EGL_WINDOW_BIT,
-                                dri2_surf->base.GLColorspace);
-
-   if (!config) {
-      _eglError(EGL_BAD_MATCH, "Unsupported surfacetype/colorspace configuration");
+   if (!dri2_drm_config_is_compatible(dri2_dpy, dri_config, surface)) {
+      _eglError(EGL_BAD_MATCH, "EGL config not compatible with GBM format");
       goto cleanup_surf;
    }
 
-   if (!dri2_drm_config_is_compatible(dri2_dpy, config, surface)) {
-      _eglError(EGL_BAD_MATCH, "EGL config not compatible with GBM format");
+   dri_config = dri2_get_dri_config(dri_bundle, EGL_WINDOW_BIT,
+                                    dri2_surf->base.GLColorspace);
+   if (!dri_config) {
+      _eglError(EGL_BAD_MATCH, "Unsupported surfacetype/colorspace configuration");
       goto cleanup_surf;
    }
 
@@ -173,14 +172,14 @@ dri2_drm_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
 
    if (dri2_dpy->dri2) {
       dri2_surf->dri_drawable =
-         dri2_dpy->dri2->createNewDrawable(dri2_dpy->dri_screen, config,
+         dri2_dpy->dri2->createNewDrawable(dri2_dpy->dri_screen, dri_config,
                                            dri2_surf->gbm_surf);
 
    } else {
       assert(dri2_dpy->swrast != NULL);
 
       dri2_surf->dri_drawable =
-         dri2_dpy->swrast->createNewDrawable(dri2_dpy->dri_screen, config,
+         dri2_dpy->swrast->createNewDrawable(dri2_dpy->dri_screen, dri_config,
                                              dri2_surf->gbm_surf);
 
    }
@@ -639,7 +638,7 @@ drm_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *disp)
                                       __DRI_ATTRIB_ALPHA_MASK, &alpha);
 
       for (unsigned j = 0; j < num_visuals; j++) {
-         struct dri2_egl_config *dri2_conf;
+         struct dri2_egl_config_bundle *dri_bundle;
 
          if (visuals[j].rgba_masks.red != red ||
              visuals[j].rgba_masks.green != green ||
@@ -652,10 +651,10 @@ drm_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *disp)
             EGL_NONE,
          };
 
-         dri2_conf = dri2_add_config(disp, dri2_dpy->driver_configs[i],
+         dri_bundle = dri2_add_config(disp, dri2_dpy->driver_configs[i],
                config_count + 1, EGL_WINDOW_BIT, attr_list, NULL);
-         if (dri2_conf) {
-            if (dri2_conf->base.ConfigID == config_count + 1)
+         if (dri_bundle) {
+            if (dri_bundle->egl_config->ConfigID == config_count + 1)
                config_count++;
             format_count[j]++;
          }
diff --git a/src/egl/drivers/dri2/platform_surfaceless.c b/src/egl/drivers/dri2/platform_surfaceless.c
index fefb2b449d0..e0e46b08ccc 100644
--- a/src/egl/drivers/dri2/platform_surfaceless.c
+++ b/src/egl/drivers/dri2/platform_surfaceless.c
@@ -110,9 +110,9 @@ dri2_surfaceless_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
                         _EGLConfig *conf, const EGLint *attrib_list)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
+   struct dri2_egl_config_bundle *dri_bundle = dri2_get_config_bundle(disp, conf);
    struct dri2_egl_surface *dri2_surf;
-   const __DRIconfig *config;
+   const __DRIconfig *dri_config;
 
    /* Make sure to calloc so all pointers
     * are originally NULL.
@@ -127,16 +127,15 @@ dri2_surfaceless_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
    if (!dri2_init_surface(&dri2_surf->base, disp, type, conf, attrib_list, false))
       goto cleanup_surface;
 
-   config = dri2_get_dri_config(dri2_conf, type,
-                                dri2_surf->base.GLColorspace);
-
-   if (!config) {
+   dri_config = dri2_get_dri_config(dri_bundle, type,
+                                    dri2_surf->base.GLColorspace);
+   if (!dri_config) {
       _eglError(EGL_BAD_MATCH, "Unsupported surfacetype/colorspace configuration");
       goto cleanup_surface;
    }
 
    dri2_surf->dri_drawable =
-      dri2_dpy->image_driver->createNewDrawable(dri2_dpy->dri_screen, config,
+      dri2_dpy->image_driver->createNewDrawable(dri2_dpy->dri_screen, dri_config,
                                                 dri2_surf);
    if (dri2_surf->dri_drawable == NULL) {
       _eglError(EGL_BAD_ALLOC, "image->createNewDrawable");
@@ -197,14 +196,14 @@ surfaceless_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *disp)
 
    for (unsigned i = 0; dri2_dpy->driver_configs[i] != NULL; i++) {
       for (unsigned j = 0; j < ARRAY_SIZE(visuals); j++) {
-         struct dri2_egl_config *dri2_conf;
+         struct dri2_egl_config_bundle *dri_bundle;
 
-         dri2_conf = dri2_add_config(disp, dri2_dpy->driver_configs[i],
+         dri_bundle = dri2_add_config(disp, dri2_dpy->driver_configs[i],
                config_count + 1, EGL_PBUFFER_BIT, NULL,
                visuals[j].rgba_masks);
 
-         if (dri2_conf) {
-            if (dri2_conf->base.ConfigID == config_count + 1)
+         if (dri_bundle) {
+            if (dri_bundle->egl_config->ConfigID == config_count + 1)
                config_count++;
             format_count[j]++;
          }
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 2a2c8214169..9c973aa0a04 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -274,11 +274,11 @@ dri2_wl_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
 {
    __DRIcreateNewDrawableFunc createNewDrawable;
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
+   struct dri2_egl_config_bundle *dri_bundle = dri2_get_config_bundle(disp, conf);
    struct wl_egl_window *window = native_window;
    struct dri2_egl_surface *dri2_surf;
    int visual_idx;
-   const __DRIconfig *config;
+   const __DRIconfig *dri_config;
 
    dri2_surf = calloc(1, sizeof *dri2_surf);
    if (!dri2_surf) {
@@ -290,10 +290,9 @@ dri2_wl_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
                           attrib_list, false))
       goto cleanup_surf;
 
-   config = dri2_get_dri_config(dri2_conf, EGL_WINDOW_BIT,
-                                dri2_surf->base.GLColorspace);
-
-   if (!config) {
+   dri_config = dri2_get_dri_config(dri_bundle, EGL_WINDOW_BIT,
+                                    dri2_surf->base.GLColorspace);
+   if (!dri_config) {
       _eglError(EGL_BAD_MATCH, "Unsupported surfacetype/colorspace configuration");
       goto cleanup_surf;
    }
@@ -301,7 +300,7 @@ dri2_wl_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
    dri2_surf->base.Width = window->width;
    dri2_surf->base.Height = window->height;
 
-   visual_idx = dri2_wl_visual_idx_from_config(dri2_dpy, config);
+   visual_idx = dri2_wl_visual_idx_from_config(dri2_dpy, dri_config);
    assert(visual_idx != -1);
 
    if (dri2_dpy->wl_dmabuf || dri2_dpy->wl_drm) {
@@ -356,7 +355,7 @@ dri2_wl_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
    else
       createNewDrawable = dri2_dpy->swrast->createNewDrawable;
 
-   dri2_surf->dri_drawable = (*createNewDrawable)(dri2_dpy->dri_screen, config,
+   dri2_surf->dri_drawable = (*createNewDrawable)(dri2_dpy->dri_screen, dri_config,
                                                   dri2_surf);
     if (dri2_surf->dri_drawable == NULL) {
       _eglError(EGL_BAD_ALLOC, "createNewDrawable");
@@ -1347,15 +1346,15 @@ dri2_wl_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *disp)
       assigned = false;
 
       for (unsigned j = 0; j < ARRAY_SIZE(dri2_wl_visuals); j++) {
-         struct dri2_egl_config *dri2_conf;
+         struct dri2_egl_config_bundle *dri_bundle;
 
          if (!(dri2_dpy->formats & (1u << j)))
             continue;
 
-         dri2_conf = dri2_add_config(disp, dri2_dpy->driver_configs[i],
+         dri_bundle = dri2_add_config(disp, dri2_dpy->driver_configs[i],
                count + 1, EGL_WINDOW_BIT, NULL, dri2_wl_visuals[j].rgba_masks);
-         if (dri2_conf) {
-            if (dri2_conf->base.ConfigID == count + 1)
+         if (dri_bundle) {
+            if (dri_bundle->egl_config->ConfigID == count + 1)
                count++;
             format_count[j]++;
             assigned = true;
@@ -1363,7 +1362,7 @@ dri2_wl_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *disp)
       }
 
       if (!assigned && dri2_dpy->is_different_gpu) {
-         struct dri2_egl_config *dri2_conf;
+         struct dri2_egl_config_bundle *dri_bundle;
          int alt_dri_image_format, c, s;
 
          /* No match for config. Try if we can blitImage convert to a visual */
@@ -1384,11 +1383,11 @@ dri2_wl_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *disp)
           * by our client gpu during PRIME blitImage conversion to a linear
           * wl_buffer, so add visual c as supported by the client renderer.
           */
-         dri2_conf = dri2_add_config(disp, dri2_dpy->driver_configs[i],
+         dri_bundle = dri2_add_config(disp, dri2_dpy->driver_configs[i],
                                      count + 1, EGL_WINDOW_BIT, NULL,
                                      dri2_wl_visuals[c].rgba_masks);
-         if (dri2_conf) {
-            if (dri2_conf->base.ConfigID == count + 1)
+         if (dri_bundle) {
+            if (dri_bundle->egl_config->ConfigID == count + 1)
                count++;
             format_count[c]++;
             if (format_count[c] == 1)
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index c8c676d2f00..10f7825f208 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -252,12 +252,12 @@ dri2_x11_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
                         const EGLint *attrib_list)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
+   struct dri2_egl_config_bundle *dri_bundle = dri2_get_config_bundle(disp, conf);
    struct dri2_egl_surface *dri2_surf;
    xcb_get_geometry_cookie_t cookie;
    xcb_get_geometry_reply_t *reply;
    xcb_generic_error_t *error;
-   const __DRIconfig *config;
+   const __DRIconfig *dri_config;
 
    (void) drv;
 
@@ -266,7 +266,7 @@ dri2_x11_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
       _eglError(EGL_BAD_ALLOC, "dri2_create_surface");
       return NULL;
    }
-   
+
    if (!dri2_init_surface(&dri2_surf->base, disp, type, conf, attrib_list, false))
       goto cleanup_surf;
 
@@ -281,22 +281,21 @@ dri2_x11_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
       dri2_surf->drawable = (uintptr_t) native_surface;
    }
 
-   config = dri2_get_dri_config(dri2_conf, type,
-                                dri2_surf->base.GLColorspace);
-
-   if (!config) {
+   dri_config = dri2_get_dri_config(dri_bundle, type,
+                                    dri2_surf->base.GLColorspace);
+   if (!dri_config) {
       _eglError(EGL_BAD_MATCH, "Unsupported surfacetype/colorspace configuration");
       goto cleanup_pixmap;
    }
 
    if (dri2_dpy->dri2) {
       dri2_surf->dri_drawable =
-         dri2_dpy->dri2->createNewDrawable(dri2_dpy->dri_screen, config,
+         dri2_dpy->dri2->createNewDrawable(dri2_dpy->dri_screen, dri_config,
                                            dri2_surf);
    } else {
       assert(dri2_dpy->swrast);
-      dri2_surf->dri_drawable = 
-         dri2_dpy->swrast->createNewDrawable(dri2_dpy->dri_screen, config,
+      dri2_surf->dri_drawable =
+         dri2_dpy->swrast->createNewDrawable(dri2_dpy->dri_screen, dri_config,
                                              dri2_surf);
    }
 
@@ -423,7 +422,7 @@ dri2_x11_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
    (void) drv;
 
    dri2_dpy->core->destroyDrawable(dri2_surf->dri_drawable);
-   
+
    if (dri2_dpy->dri2) {
       xcb_dri2_destroy_drawable (dri2_dpy->conn, dri2_surf->drawable);
    } else {
@@ -803,13 +802,13 @@ dri2_x11_add_configs_for_visuals(struct dri2_egl_display *dri2_dpy,
       visuals = xcb_depth_visuals(d.data);
 
       for (int i = 0; i < xcb_depth_visuals_length(d.data); i++) {
-	 if (class_added[visuals[i]._class])
-	    continue;
+         if (class_added[visuals[i]._class])
+            continue;
 
-	 class_added[visuals[i]._class] = EGL_TRUE;
+         class_added[visuals[i]._class] = EGL_TRUE;
 
-	 for (int j = 0; dri2_dpy->driver_configs[j]; j++) {
-            struct dri2_egl_config *dri2_conf;
+         for (int j = 0; dri2_dpy->driver_configs[j]; j++) {
+            struct dri2_egl_config_bundle *dri_bundle;
             const __DRIconfig *config = dri2_dpy->driver_configs[j];
 
             const EGLint config_attrs[] = {
@@ -825,32 +824,21 @@ dri2_x11_add_configs_for_visuals(struct dri2_egl_display *dri2_dpy,
                0,
             };
 
-            dri2_conf = dri2_add_config(disp, config, config_count + 1,
+            dri_bundle = dri2_add_config(disp, config, config_count + 1,
                                         surface_type, config_attrs,
                                         rgba_masks);
-            if (dri2_conf)
-               if (dri2_conf->base.ConfigID == config_count + 1)
+            if (dri_bundle)
+               if (dri_bundle->egl_config->ConfigID == config_count + 1)
                   config_count++;
 
-            /* Allow a 24-bit RGB visual to match a 32-bit RGBA EGLConfig.
-             * Ditto for 30-bit RGB visuals to match a 32-bit RGBA EGLConfig.
-             * Otherwise it will only match a 32-bit RGBA visual.  On a
-             * composited window manager on X11, this will make all of the
-             * EGLConfigs with destination alpha get blended by the
-             * compositor.  This is probably not what the application
-             * wants... especially on drivers that only have 32-bit RGBA
-             * EGLConfigs! */
-            if (d.data->depth == 24 || d.data->depth == 30) {
-               rgba_masks[3] =
-                  ~(rgba_masks[0] | rgba_masks[1] | rgba_masks[2]);
-               dri2_conf = dri2_add_config(disp, config, config_count + 1,
-                                           surface_type, config_attrs,
-                                           rgba_masks);
-               if (dri2_conf)
-                  if (dri2_conf->base.ConfigID == config_count + 1)
-                     config_count++;
-            }
-	 }
+            rgba_masks[3] = ~(rgba_masks[0] | rgba_masks[1] | rgba_masks[2]);
+            dri_bundle = dri2_add_config(disp, config, config_count + 1,
+                                        surface_type, config_attrs,
+                                        rgba_masks);
+            if (dri_bundle)
+               if (dri_bundle->egl_config->ConfigID == config_count + 1)
+                  config_count++;
+         }
       }
 
       xcb_depth_next(&d);
diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index 189212745ce..df5d115528d 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -142,10 +142,10 @@ dri3_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
                     const EGLint *attrib_list)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
+   struct dri2_egl_config_bundle *dri_bundle = dri2_get_config_bundle(disp, conf);
    struct dri3_egl_surface *dri3_surf;
-   const __DRIconfig *dri_config;
    xcb_drawable_t drawable;
+   const __DRIconfig *dri_config;
 
    (void) drv;
 
@@ -168,12 +168,11 @@ dri3_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
       drawable = (uintptr_t) native_surface;
    }
 
-   dri_config = dri2_get_dri_config(dri2_conf, type,
+   dri_config = dri2_get_dri_config(dri_bundle, type,
                                     dri3_surf->surf.base.GLColorspace);
-
    if (!dri_config) {
       _eglError(EGL_BAD_MATCH, "Unsupported surfacetype/colorspace configuration");
-      goto cleanup_pixmap;
+      goto cleanup_surf;
    }
 
    if (loader_dri3_drawable_init(dri2_dpy->conn, drawable,
diff --git a/src/egl/drivers/haiku/egl_haiku.cpp b/src/egl/drivers/haiku/egl_haiku.cpp
index 517c264088a..248310c6cb4 100644
--- a/src/egl/drivers/haiku/egl_haiku.cpp
+++ b/src/egl/drivers/haiku/egl_haiku.cpp
@@ -57,7 +57,7 @@ _EGL_DRIVER_STANDARD_TYPECASTS(haiku_egl)
 
 struct haiku_egl_config
 {
-	_EGLConfig         base;
+	_EGLConfig         *egl_config;
 };
 
 struct haiku_egl_context
@@ -138,6 +138,13 @@ haiku_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
 	return EGL_TRUE;
 }
 
+static void
+haiku_free_root(struct haiku_egl_config *root) {
+   if (root) {
+      free(root->egl_config);
+      free(root);
+   }
+}
 
 static EGLBoolean
 haiku_add_configs_for_visuals(_EGLDisplay *disp)
@@ -149,47 +156,51 @@ haiku_add_configs_for_visuals(_EGLDisplay *disp)
 	if (!conf)
 		return _eglError(EGL_BAD_ALLOC, "haiku_add_configs_for_visuals");
 
-	_eglInitConfig(&conf->base, disp, 1);
+	conf->egl_config = calloc(1, sizeof (*conf->egl_config));
+	if (!conf->egl_config)
+		return _eglError(EGL_BAD_ALLOC, "haiku_add_configs_for_visuals");
+
+	_eglInitConfig(conf->egl_config, disp, 1);
 	TRACE("Config inited\n");
 
-	_eglSetConfigKey(&conf->base, EGL_RED_SIZE, 8);
-	_eglSetConfigKey(&conf->base, EGL_BLUE_SIZE, 8);
-	_eglSetConfigKey(&conf->base, EGL_GREEN_SIZE, 8);
-	_eglSetConfigKey(&conf->base, EGL_LUMINANCE_SIZE, 0);
-	_eglSetConfigKey(&conf->base, EGL_ALPHA_SIZE, 8);
-	_eglSetConfigKey(&conf->base, EGL_COLOR_BUFFER_TYPE, EGL_RGB_BUFFER);
-	EGLint r = (_eglGetConfigKey(&conf->base, EGL_RED_SIZE)
-		+ _eglGetConfigKey(&conf->base, EGL_GREEN_SIZE)
-		+ _eglGetConfigKey(&conf->base, EGL_BLUE_SIZE)
-		+ _eglGetConfigKey(&conf->base, EGL_ALPHA_SIZE));
-	_eglSetConfigKey(&conf->base, EGL_BUFFER_SIZE, r);
-	_eglSetConfigKey(&conf->base, EGL_CONFIG_CAVEAT, EGL_NONE);
-	_eglSetConfigKey(&conf->base, EGL_CONFIG_ID, 1);
-	_eglSetConfigKey(&conf->base, EGL_BIND_TO_TEXTURE_RGB, EGL_FALSE);
-	_eglSetConfigKey(&conf->base, EGL_BIND_TO_TEXTURE_RGBA, EGL_FALSE);
-	_eglSetConfigKey(&conf->base, EGL_STENCIL_SIZE, 0);
-	_eglSetConfigKey(&conf->base, EGL_TRANSPARENT_TYPE, EGL_NONE);
-	_eglSetConfigKey(&conf->base, EGL_NATIVE_RENDERABLE, EGL_TRUE); // Let's say yes
-	_eglSetConfigKey(&conf->base, EGL_NATIVE_VISUAL_ID, 0); // No visual
-	_eglSetConfigKey(&conf->base, EGL_NATIVE_VISUAL_TYPE, EGL_NONE); // No visual
-	_eglSetConfigKey(&conf->base, EGL_RENDERABLE_TYPE, 0x8);
-	_eglSetConfigKey(&conf->base, EGL_SAMPLE_BUFFERS, 0); // TODO: How to get the right value ?
-	_eglSetConfigKey(&conf->base, EGL_SAMPLES, _eglGetConfigKey(&conf->base, EGL_SAMPLE_BUFFERS) == 0 ? 0 : 0);
-	_eglSetConfigKey(&conf->base, EGL_DEPTH_SIZE, 24); // TODO: How to get the right value ?
-	_eglSetConfigKey(&conf->base, EGL_LEVEL, 0);
-	_eglSetConfigKey(&conf->base, EGL_MAX_PBUFFER_WIDTH, 0); // TODO: How to get the right value ?
-	_eglSetConfigKey(&conf->base, EGL_MAX_PBUFFER_HEIGHT, 0); // TODO: How to get the right value ?
-	_eglSetConfigKey(&conf->base, EGL_MAX_PBUFFER_PIXELS, 0); // TODO: How to get the right value ?
-	_eglSetConfigKey(&conf->base, EGL_SURFACE_TYPE, EGL_WINDOW_BIT /*| EGL_PIXMAP_BIT | EGL_PBUFFER_BIT*/);
+	_eglSetConfigKey(conf->egl_config, EGL_RED_SIZE, 8);
+	_eglSetConfigKey(conf->egl_config, EGL_BLUE_SIZE, 8);
+	_eglSetConfigKey(conf->egl_config, EGL_GREEN_SIZE, 8);
+	_eglSetConfigKey(conf->egl_config, EGL_LUMINANCE_SIZE, 0);
+	_eglSetConfigKey(conf->egl_config, EGL_ALPHA_SIZE, 8);
+	_eglSetConfigKey(conf->egl_config, EGL_COLOR_BUFFER_TYPE, EGL_RGB_BUFFER);
+	EGLint r = (_eglGetConfigKey(&conf->egl_config, EGL_RED_SIZE)
+		+ _eglGetConfigKey(&conf->egl_config, EGL_GREEN_SIZE)
+		+ _eglGetConfigKey(&conf->egl_config, EGL_BLUE_SIZE)
+		+ _eglGetConfigKey(&conf->egl_config, EGL_ALPHA_SIZE));
+	_eglSetConfigKey(conf->egl_config, EGL_BUFFER_SIZE, r);
+	_eglSetConfigKey(conf->egl_config, EGL_CONFIG_CAVEAT, EGL_NONE);
+	_eglSetConfigKey(conf->egl_config, EGL_CONFIG_ID, 1);
+	_eglSetConfigKey(conf->egl_config, EGL_BIND_TO_TEXTURE_RGB, EGL_FALSE);
+	_eglSetConfigKey(conf->egl_config, EGL_BIND_TO_TEXTURE_RGBA, EGL_FALSE);
+	_eglSetConfigKey(conf->egl_config, EGL_STENCIL_SIZE, 0);
+	_eglSetConfigKey(conf->egl_config, EGL_TRANSPARENT_TYPE, EGL_NONE);
+	_eglSetConfigKey(conf->egl_config, EGL_NATIVE_RENDERABLE, EGL_TRUE); // Let's say yes
+	_eglSetConfigKey(conf->egl_config, EGL_NATIVE_VISUAL_ID, 0); // No visual
+	_eglSetConfigKey(conf->egl_config, EGL_NATIVE_VISUAL_TYPE, EGL_NONE); // No visual
+	_eglSetConfigKey(conf->egl_config, EGL_RENDERABLE_TYPE, 0x8);
+	_eglSetConfigKey(conf->egl_config, EGL_SAMPLE_BUFFERS, 0); // TODO: How to get the right value ?
+	_eglSetConfigKey(conf->egl_config, EGL_SAMPLES, _eglGetConfigKey(&conf->egl_config, EGL_SAMPLE_BUFFERS) == 0 ? 0 : 0);
+	_eglSetConfigKey(conf->egl_config, EGL_DEPTH_SIZE, 24); // TODO: How to get the right value ?
+	_eglSetConfigKey(conf->egl_config, EGL_LEVEL, 0);
+	_eglSetConfigKey(conf->egl_config, EGL_MAX_PBUFFER_WIDTH, 0); // TODO: How to get the right value ?
+	_eglSetConfigKey(conf->egl_config, EGL_MAX_PBUFFER_HEIGHT, 0); // TODO: How to get the right value ?
+	_eglSetConfigKey(conf->egl_config, EGL_MAX_PBUFFER_PIXELS, 0); // TODO: How to get the right value ?
+	_eglSetConfigKey(conf->egl_config, EGL_SURFACE_TYPE, EGL_WINDOW_BIT /*| EGL_PIXMAP_BIT | EGL_PBUFFER_BIT*/);
 
 	TRACE("Config configuated\n");
-	if (!_eglValidateConfig(&conf->base, EGL_FALSE)) {
+	if (!_eglValidateConfig(&conf->egl_config, EGL_FALSE)) {
 		_eglLog(_EGL_DEBUG, "Haiku: failed to validate config");
 		goto cleanup;
 	}
 	TRACE("Validated config\n");
 
-	_eglLinkConfig(&conf->base);
+	_eglLinkConfig(conf->egl_config, conf, free);
 	if (!_eglGetArraySize(disp->Configs)) {
 		_eglLog(_EGL_WARNING, "Haiku: failed to create any config");
 		goto cleanup;
diff --git a/src/egl/main/eglconfig.c b/src/egl/main/eglconfig.c
index 72cd73d5179..959902c8b26 100644
--- a/src/egl/main/eglconfig.c
+++ b/src/egl/main/eglconfig.c
@@ -34,6 +34,7 @@
 
 
 #include <stdlib.h>
+#include <stdio.h>
 #include <string.h>
 #include <assert.h>
 #include "c99_compat.h"
@@ -44,9 +45,6 @@
 #include "eglcurrent.h"
 #include "egllog.h"
 
-
-
-
 /**
  * Init the given _EGLconfig to default values.
  * \param id  the configuration's ID.
@@ -71,7 +69,6 @@ _eglInitConfig(_EGLConfig *conf, _EGLDisplay *disp, EGLint id)
    conf->ComponentType = EGL_COLOR_COMPONENT_TYPE_FIXED_EXT;
 }
 
-
 /**
  * Link a config to its display and return the handle of the link.
  * The handle can be passed to client directly.
@@ -79,7 +76,7 @@ _eglInitConfig(_EGLConfig *conf, _EGLDisplay *disp, EGLint id)
  * Note that we just save the ptr to the config (we don't copy the config).
  */
 EGLConfig
-_eglLinkConfig(_EGLConfig *conf)
+_eglLinkConfig(_EGLConfig *conf, void *root, void (*root_free_cb)(void *))
 {
    _EGLDisplay *disp = conf->Display;
 
@@ -89,12 +86,20 @@ _eglLinkConfig(_EGLConfig *conf)
 
    if (!disp->Configs) {
       disp->Configs = _eglCreateArray("Config", 16);
-      if (!disp->Configs)
+      disp->ConfigRoots = _eglCreateArray("Config Root", 16);
+      disp->ConfigRootFreeCBs = _eglCreateArray("Config Root Free CB", 16);
+
+      if (!disp->Configs || !disp->ConfigRoots || !disp->ConfigRootFreeCBs)
          return (EGLConfig) NULL;
    }
 
    _eglAppendArray(disp->Configs, (void *) conf);
 
+   if (!_eglFindArray(disp->ConfigRoots, root)) {
+      _eglAppendArray(disp->ConfigRoots, root);
+      _eglAppendArray(disp->ConfigRootFreeCBs, root_free_cb);
+   }
+
    return (EGLConfig) conf;
 }
 
@@ -258,6 +263,9 @@ static const struct {
    { EGL_COLOR_COMPONENT_TYPE_EXT,  ATTRIB_TYPE_ENUM,
                                     ATTRIB_CRITERION_EXACT,
                                     EGL_COLOR_COMPONENT_TYPE_FIXED_EXT },
+   { EGL_CONFIG_SELECT_GROUP_MESA,  ATTRIB_TYPE_INTEGER,
+                                    ATTRIB_CRITERION_IGNORE,
+                                    0 },
 };
 
 
@@ -296,6 +304,8 @@ _eglValidateConfig(const _EGLConfig *conf, EGLBoolean for_matching)
             if (val > 1 || val < 0)
                valid = EGL_FALSE;
             break;
+         case EGL_CONFIG_SELECT_GROUP_MESA:
+            break;
          default:
             if (val < 0)
                valid = EGL_FALSE;
@@ -608,6 +618,10 @@ _eglCompareConfigs(const _EGLConfig *conf1, const _EGLConfig *conf2,
    if (conf1 == conf2)
       return 0;
 
+   val1 = conf1->ConfigSelectGroup - conf2->ConfigSelectGroup;
+   if (val1)
+      return val1;
+
    /* the enum values have the desired ordering */
    STATIC_ASSERT(EGL_NONE < EGL_SLOW_CONFIG);
    STATIC_ASSERT(EGL_SLOW_CONFIG < EGL_NON_CONFORMANT_CONFIG);
diff --git a/src/egl/main/eglconfig.h b/src/egl/main/eglconfig.h
index 605289de536..233178337d6 100644
--- a/src/egl/main/eglconfig.h
+++ b/src/egl/main/eglconfig.h
@@ -89,6 +89,7 @@ struct _egl_config
    EGLint FramebufferTargetAndroid;
    EGLint RecordableAndroid;
    EGLint ComponentType;
+   EGLint ConfigSelectGroup;
 };
 
 
@@ -139,6 +140,7 @@ _eglOffsetOfConfig(EGLint attr)
    ATTRIB_MAP(EGL_FRAMEBUFFER_TARGET_ANDROID, FramebufferTargetAndroid);
    ATTRIB_MAP(EGL_RECORDABLE_ANDROID,        RecordableAndroid);
    ATTRIB_MAP(EGL_COLOR_COMPONENT_TYPE_EXT,  ComponentType);
+   ATTRIB_MAP(EGL_CONFIG_SELECT_GROUP_MESA,  ConfigSelectGroup);
 #undef ATTRIB_MAP
    default:
       return -1;
@@ -179,7 +181,7 @@ _eglInitConfig(_EGLConfig *config, _EGLDisplay *disp, EGLint id);
 
 
 extern EGLConfig
-_eglLinkConfig(_EGLConfig *conf);
+_eglLinkConfig(_EGLConfig *conf, void *root, void (*root_free_cb)(void *));
 
 
 extern _EGLConfig *
diff --git a/src/egl/main/egldisplay.c b/src/egl/main/egldisplay.c
index ba5f84510fe..9fa172a3a58 100644
--- a/src/egl/main/egldisplay.c
+++ b/src/egl/main/egldisplay.c
@@ -37,6 +37,7 @@
 #include <string.h>
 #include "c11/threads.h"
 #include "util/u_atomic.h"
+#include "util/macros.h"
 
 #include "eglcontext.h"
 #include "eglcurrent.h"
@@ -238,7 +239,7 @@ _eglFindDisplay(_EGLPlatformType plat, void *plat_dpy)
          disp->Platform = plat;
          disp->PlatformDisplay = plat_dpy;
 
-         /* add to the display list */ 
+         /* add to the display list */
          disp->Next = _eglGlobal.DisplayList;
          _eglGlobal.DisplayList = disp;
       }
@@ -303,13 +304,32 @@ _eglReleaseDisplayResources(_EGLDriver *drv, _EGLDisplay *display)
 /**
  * Free all the data hanging of an _EGLDisplay object, but not
  * the object itself.
+ *
+ * Will free the Configs before the ConfigRoots.
  */
 void
 _eglCleanupDisplay(_EGLDisplay *disp)
 {
-   if (disp->Configs) {
+   if (disp->ConfigRoots) {
       _eglDestroyArray(disp->Configs, free);
       disp->Configs = NULL;
+
+      if (_eglGetArraySize(disp->ConfigRoots)
+            != _eglGetArraySize(disp->ConfigRootFreeCBs)) {
+         unreachable("Every config root has exactly one free callback");
+         return;
+      }
+
+      for (EGLint i = 0; i < _eglGetArraySize(disp->ConfigRoots); ++i) {
+         void (*root_free_cb)(void *) = disp->ConfigRootFreeCBs->Elements[i];
+         if (root_free_cb)
+            root_free_cb(disp->ConfigRoots->Elements[i]);
+      }
+
+      _eglDestroyArray(disp->ConfigRoots, NULL);
+      _eglDestroyArray(disp->ConfigRootFreeCBs, NULL);
+      disp->ConfigRoots = NULL;
+      disp->ConfigRootFreeCBs = NULL;
    }
 
    /* XXX incomplete */
@@ -344,7 +364,7 @@ EGLBoolean
 _eglCheckResource(void *res, _EGLResourceType type, _EGLDisplay *disp)
 {
    _EGLResource *list = disp->ResourceLists[type];
-   
+
    if (!res)
       return EGL_FALSE;
 
diff --git a/src/egl/main/egldisplay.h b/src/egl/main/egldisplay.h
index cfd0ff66d64..9a765d7a936 100644
--- a/src/egl/main/egldisplay.h
+++ b/src/egl/main/egldisplay.h
@@ -181,7 +181,10 @@ struct _egl_display
    char ClientAPIsString[100];                     /**< EGL_CLIENT_APIS */
    char ExtensionsString[_EGL_MAX_EXTENSIONS_LEN]; /**< EGL_EXTENSIONS */
 
+   /* All initialized and destroyed at the same time */
    _EGLArray *Configs;
+   _EGLArray *ConfigRoots;
+   _EGLArray *ConfigRootFreeCBs;
 
    /* lists of resources */
    _EGLResource *ResourceLists[_EGL_NUM_RESOURCES];
diff --git a/src/egl/main/eglglobals.c b/src/egl/main/eglglobals.c
index 2fc64bc52c3..45e82258b54 100644
--- a/src/egl/main/eglglobals.c
+++ b/src/egl/main/eglglobals.c
@@ -70,7 +70,8 @@ struct _egl_global _eglGlobal =
    " EGL_EXT_device_query"
    " EGL_EXT_platform_base"
    " EGL_KHR_client_get_all_proc_addresses"
-   " EGL_KHR_debug",
+   " EGL_KHR_debug"
+   " EGL_MESA_config_select_group",
 
    .PlatformExtensionString =
 #ifdef HAVE_WAYLAND_PLATFORM
diff --git a/src/glx/dri_common.c b/src/glx/dri_common.c
index 2db29fd6abb..8cfa932ef67 100644
--- a/src/glx/dri_common.c
+++ b/src/glx/dri_common.c
@@ -178,7 +178,7 @@ static const struct
       __ATTRIB(__DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE,
                      bindToMipmapTexture),
       __ATTRIB(__DRI_ATTRIB_YINVERTED, yInverted),
-      __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE, sRGBCapable)
+      __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE, sRGBCapable),
 };
 
 static int
diff --git a/src/mesa/drivers/dri/common/dri_util.c b/src/mesa/drivers/dri/common/dri_util.c
index ac3a04bceff..357157ed12c 100644
--- a/src/mesa/drivers/dri/common/dri_util.c
+++ b/src/mesa/drivers/dri/common/dri_util.c
@@ -30,7 +30,7 @@
  * driver doesn't really \e have to use any of this - it's optional.  But, some
  * useful stuff is done here that otherwise would have to be duplicated in most
  * drivers.
- * 
+ *
  * Basically, these utility functions take care of some of the dirty details of
  * screen initialization, context creation, context binding, DRM setup, etc.
  *
@@ -215,7 +215,7 @@ driSWRastCreateNewScreen2(int scrn, const __DRIextension **extensions,
 
 /**
  * Destroy the per-screen private information.
- * 
+ *
  * \internal
  * This function calls __DriverAPIRec::DestroyScreen on \p screenPrivate, calls
  * drmClose(), and finally frees \p screenPrivate.
@@ -242,6 +242,22 @@ static const __DRIextension **driGetExtensions(__DRIscreen *psp)
     return psp->extensions;
 }
 
+/**
+ * dri configs are "egl compatible" if they are identical, ignoring their
+ * doubleBufferMode and sRGBCapable.
+ */
+static bool
+driConfigIsEglCompatible(const __DRIconfig *a, const __DRIconfig *b)
+{
+    struct gl_config a_modes;
+
+    memcpy(&a_modes, &a->modes, sizeof(a_modes));
+    a_modes.doubleBufferMode = b->modes.doubleBufferMode;
+    a_modes.sRGBCapable = b->modes.sRGBCapable;
+
+    return memcmp(&a_modes, &b->modes, sizeof(a_modes)) == 0;
+}
+
 /*@}*/
 
 
@@ -514,7 +530,7 @@ driCreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
 
 /**
  * Destroy the per-context private information.
- * 
+ *
  * \internal
  * This function calls __DriverAPIRec::DestroyContext on \p contextPrivate, calls
  * drmDestroyContext(), and finally frees \p contextPrivate.
@@ -581,19 +597,19 @@ static int driBindContext(__DRIcontext *pcp,
 
 /**
  * Unbind context.
- * 
+ *
  * \param scrn the screen.
  * \param gc context.
  *
  * \return \c GL_TRUE on success, or \c GL_FALSE on failure.
- * 
+ *
  * \internal
  * This function calls __DriverAPIRec::UnbindContext, and then decrements
  * __DRIdrawableRec::refcount which must be non-zero for a successful
  * return.
- * 
+ *
  * While casting the opaque private pointers associated with the parameters
- * into their respective real types it also assures they are not \c NULL. 
+ * into their respective real types it also assures they are not \c NULL.
  */
 static int driUnbindContext(__DRIcontext *pcp)
 {
@@ -801,7 +817,8 @@ const __DRIcoreExtension driCoreExtension = {
     .copyContext                = driCopyContext,
     .destroyContext             = driDestroyContext,
     .bindContext                = driBindContext,
-    .unbindContext              = driUnbindContext
+    .unbindContext              = driUnbindContext,
+    .configIsEglCompatible      = driConfigIsEglCompatible,
 };
 
 /** DRI2 interface */
diff --git a/src/mesa/drivers/dri/common/utils.c b/src/mesa/drivers/dri/common/utils.c
index 5a66bcf8e05..287fb277893 100644
--- a/src/mesa/drivers/dri/common/utils.c
+++ b/src/mesa/drivers/dri/common/utils.c
@@ -57,18 +57,18 @@
 
 /**
  * Create the \c GL_RENDERER string for DRI drivers.
- * 
+ *
  * Almost all DRI drivers use a \c GL_RENDERER string of the form:
  *
  *    "Mesa DRI <chip> <driver date> <AGP speed) <CPU information>"
  *
  * Using the supplied chip name, driver data, and AGP speed, this function
  * creates the string.
- * 
+ *
  * \param buffer         Buffer to hold the \c GL_RENDERER string.
  * \param hardware_name  Name of the hardware.
  * \param agp_mode       AGP mode (speed).
- * 
+ *
  * \returns
  * The length of the string stored in \c buffer.  This does \b not include
  * the terminating \c NUL character.
@@ -91,7 +91,7 @@ driGetRendererString( char * buffer, const char * hardware_name,
    case 8:
       offset += sprintf( & buffer[ offset ], " AGP %ux", agp_mode );
       break;
-	
+
    default:
       break;
    }
@@ -110,11 +110,11 @@ driGetRendererString( char * buffer, const char * hardware_name,
 
 /**
  * Creates a set of \c struct gl_config that a driver will expose.
- * 
+ *
  * A set of \c struct gl_config will be created based on the supplied
  * parameters.  The number of modes processed will be 2 *
  * \c num_depth_stencil_bits * \c num_db_modes.
- * 
+ *
  * For the most part, data is just copied from \c depth_bits, \c stencil_bits,
  * \c db_modes, and \c visType into each \c struct gl_config element.
  * However, the meanings of \c fb_format and \c fb_type require further
@@ -126,7 +126,7 @@ driGetRendererString( char * buffer, const char * hardware_name,
  * \c GL_UNSIGNED_SHORT_5_6_5_REV is specified with \c GL_RGB, bits [15:11]
  * are the blue value, bits [10:5] are the green value, and bits [4:0] are
  * the red value.
- * 
+ *
  * One sublte issue is the combination of \c GL_RGB  or \c GL_BGR and either
  * of the \c GL_UNSIGNED_INT_8_8_8_8 modes.  The resulting mask values in the
  * \c struct gl_config structure is \b identical to the \c GL_RGBA or
@@ -135,7 +135,7 @@ driGetRendererString( char * buffer, const char * hardware_name,
  * still uses 32-bits.
  *
  * If in doubt, look at the tables used in the function.
- * 
+ *
  * \param ptr_to_modes  Pointer to a pointer to a linked list of
  *                      \c struct gl_config.  Upon completion, a pointer to
  *                      the next element to be process will be stored here.
@@ -345,6 +345,7 @@ driCreateConfigs(mesa_format format,
 		    modes->yInverted = GL_TRUE;
 		    modes->sRGBCapable = is_srgb;
 		    modes->mutableRenderBuffer = mutable_render_buffer;
+            modes->configSelectGroup = 0;
 		}
 	    }
 	}
@@ -371,7 +372,7 @@ __DRIconfig **driConcatConfigs(__DRIconfig **a,
     j = 0;
     while (b[j] != NULL)
 	j++;
-   
+
     all = malloc((i + j + 1) * sizeof *all);
     index = 0;
     for (i = 0; a[i] != NULL; i++)
@@ -430,6 +431,7 @@ static const struct { unsigned int attrib, offset; } attribMap[] = {
     __ATTRIB(__DRI_ATTRIB_YINVERTED,			yInverted),
     __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE,	sRGBCapable),
     __ATTRIB(__DRI_ATTRIB_MUTABLE_RENDER_BUFFER,	mutableRenderBuffer),
+    __ATTRIB(__DRI_ATTRIB_CONFIG_SELECT_GROUP, configSelectGroup),
 
     /* The struct field doesn't matter here, these are handled by the
      * switch in driGetConfigAttribIndex.  We need them in the array
@@ -464,7 +466,7 @@ driGetConfigAttribIndex(const __DRIconfig *config,
         /* any other int-sized field */
 	*value = *(unsigned int *)
 	    ((char *) &config->modes + attribMap[index].offset);
-	
+
 	break;
     }
 
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 76905f60662..5414bad417b 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -216,6 +216,9 @@ struct gl_config
 
    /* EGL_KHR_mutable_render_buffer */
    GLuint mutableRenderBuffer; /* bool */
+
+   /* EGL_MESA_config_select_group */
+   GLint configSelectGroup;
 };
 
 
